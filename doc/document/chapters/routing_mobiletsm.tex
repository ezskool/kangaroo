As we already showed, there was no way to get around at least adapting an existing routing engine. As Traveling Salesman is the one to use as a basis, our version of Traveling Salesman implementing the routing interface defined within the Kangaroo routing Framework is called \emph{MobileTSM}. The folling will summarize its structure, explain the most important changes in contrast to the original version of Traveling Salesman and give reasons for the adaptions.

\subsection{What are the problems?}

Coming up with the decision for using Traveling Salesman, there were several issues to work on:

\begin{enumerate}
	\item \textbf{Data storage}
	
		The data storage modules (data sets in Traveling Salesman's terminology) that come with the project can be considered unoptimized or even bad with respect to efficency and performance as needed for a mobile application. There are several different types of data set modules with different approaches of storing and organizing data.\newline
		
		Generally, but on Android's mobile platform in particular, there are two contradictory goals for the data storage architecture. Since Android restricts the heap space for an application to (at this time) 16 megabytes, the map area that can be cached in memory, is limited to several square kilometers, depending of course on data density. Thus one is forced to filter map elements before loading into memory.
		As not only memory is expensive, but also data access to a flash card or a database, a compromise has to be found between loading the whole map into memory and accessing the persistent map database for every sinle element requested by the routing engine. \newline
		
		TODO: give values
		
	\item \textbf{Routing data}
	
		By default, Traveling Salesman performs every routing operation on the original set of data not dropping elements that do not affect the result of the operation. An example for elements of this type are nodes, that geographically shape the curvature of a street but do not introduce a junction. A node of this type will be called \emph{intermediate way node} and is dispensable for routing operations unless it is the nearest node to the starting or destination point of a route.\newline
		
		Both memory space occupied by the map and time consumption of a routing operation can be reduced by ignoring intermediate way nodes. Nethertheless one cannot dispense with intermediate way nodes close to starting and destination point which implies an individual routing data set for every routing operation. At first sight this induviduality runs contrary to Traveling Salesman's architecture when aiming at keeping compatibility.\newline			
		
		TODO: give values
											
	\item \textbf{Searching algorithm}
	
		When given two pairs of geographical coordinates and an order to find a route between these two, one has in principle to find the nearest street nodes to starting and destination locations prior to the actual routing operation. This is because non-trivial routing operations can only be performed on a routing graph between vertices. Thus one has to translate from a geographical location to the vertex (node) that best matches it. This can be considered the street node with minimal distance to the given location.\newline
				
		A naive ansatz to finding the nearest street node 	to a geoprahical location would be to iterate over all street nodes, calculate distance between the location and each street node and select the one with minimal distance. Exactly this is done by Traveling Salesman resulting in an extremly time consuming routing process.\newline
		
		TODO: give values

\end{enumerate}


\subsection{What is our solution?}

As just explained in the previous section, three main issues have to be handled: find an efficient data storage archtitecture, reduce and indivualize routing data and improve the search algorithm for nearest nodes. The first two will be outlined conjointly while the last one has an individual section.

\subsubsection{Storing and handling of routing data}

The basic idea to circumvent the issues with storage and handling of frouting data is to introduce a module, the \texttt{MobileDataSetProvider}, that can be queried for a specialized set of routing data which is compatible with Traveling Salesman and optimized for an individual routing operation. Any Traveling Salesman router may then be called with a reference to this individual data set.\newline

The data set provider itself reads data from any suitable data source (for example from database or a file data stream). Since even individualized data sets will have a large intersection, data is cached in memory to a great extent.

\subsubsection{Classes and interfaces}

\emph{MobileTSM} introduces derivates of Traveling Salesman's classes\texttt{Node}, \texttt{Way} and





\begin{itemize}
		
	\item Class \texttt{MobileTSMRoutingEngine}
	
		The class \texttt{MobileRoutingEngine} is the \emph{MobileTSM} implementation of a \texttt{RoutingEngine}.
		
	\item Class \texttt{Vehicle}
		
	\item Class \texttt{Limits}

\end{itemize}
