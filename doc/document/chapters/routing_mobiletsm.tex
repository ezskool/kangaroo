TODO: review and finalize this chapter

TODO: Andi: check that I divided the routing chapters correctly (generic vs. android specific)

The interface between the main software core and the routing engine has to be designed independently of any specific routing engine, maintaining an abstraction level that allows to exchange the routing backend easily without any impact on the main software part. We will give an overview of the routing interface, which was designed to be compliant with this requirements.

\subsubsection{Classes and interfaces}

There is one Java interface and three Java classes that can be considered as the main members of the Kangaroo routing framework.

\begin{itemize}

	\item Interface \texttt{RoutingEngine}
	
		The \texttt{RoutingEngine} interface is the main interface between the routing engine and the part that is using its routing service. It provides methods to find a route between locations and to find street nodes and Points Of Interest near a location.
		
	\item Class \texttt{RouteParameter}
	
		An object of this class is returned by the routing engine when having searched the map for a route between two locations. It has methods to return the length of the route and the time it will take to travel the route. Additionally, it may contain an object representing the route itself.
	
	\item Class \texttt{Place}
	
		This class is an abstract representation of a geographic location. It imperatively consists of a pair of geographical coordinates (latitude and longitude) and may in addition contain a name or a reference to Openstreetmap elements associated with it.
	
	\item Class \texttt{Limits}
	
		This class is used to define geographical constraints for searches on the map.

\end{itemize}



As we already showed, there was no way to get around at least adapting an existing routing engine. As Traveling Salesman is the one to use as a basis, our version of Traveling Salesman implementing the routing interface defined within the Kangaroo routing Framework is called \emph{MobileTSM}. The folling will summarize its structure, explain the most important changes in contrast to the original version of Traveling Salesman and give reasons for the adaptions.

\subsubsection{Main problems arising with decision for TSM}


Coming up with the decision for using Traveling Salesman, there were several issues to work on:

\begin{enumerate}
	\item \textbf{Data storage}
	
		The data storage modules (data sets in Traveling Salesman's terminology) that come with the project can be considered unoptimized or even bad with respect to efficency and performance as needed for a mobile application. There are several different types of data set modules with different approaches of storing and organizing data.\newline
		
		Generally, but on Android's mobile platform in particular, there are two contradictory goals for the data storage architecture. Since Android restricts the heap space for an application to (at this time) 16 megabytes, the map area that can be cached in memory, is limited to several square kilometers, depending of course on data density. Thus one is forced to filter map elements before loading into memory.
		As not only memory is expensive, but also data access to a flash card or a database, a compromise has to be found between loading the whole map into memory and accessing the persistent map database for every single element requested by the routing engine. \newline
		
		TODO: give values
		
	\item \textbf{Routing data}
	
		By default, Traveling Salesman performs every routing operation on the original set of data not dropping elements that do not affect the result of the operation. An example for elements of this type are nodes, that geographically shape the curvature of a street but do not introduce a junction. A node of this type will be called \emph{intermediate way node} and is dispensable for routing operations unless it is the nearest node to the starting or destination point of a route.\newline
		
		Both memory space occupied by the map and time consumption of a routing operation can be reduced by ignoring intermediate way nodes. Nethertheless one cannot dispense with intermediate way nodes close to starting and destination point. This implies an individual routing data set for every routing operation. At first sight this induviduality runs contrary to Traveling Salesman's architecture when aiming at keeping compatibility.\newline		
		
		TODO: give values
											
	\item \textbf{Searching algorithm}
	
		When given two pairs of geographical coordinates and an order to find a route between these two, one has to find the nearest street nodes to starting and destination locations prior to the actual routing operation. This is because non-trivial routing operations can only be performed on a routing graph between vertices. Thus one has to translate from a geographical location to the vertex (node) that best matches it. This can be considered the street node with minimal distance to the given location.\newline
				
		A naive ansatz to finding the nearest street node 	to a geoprahical location would be to iterate over all street nodes, calculate the distance between the location and each street node and select the one with minimal distance. Exactly this is done by Traveling Salesman resulting in an extremly time consuming routing process.\newline
		
		TODO: give values

\end{enumerate}


\subsubsection{Approaches for main problems arising with decision for TSM}

As just explained in the previous section, three main issues have to be handled: reduce and individualize routing data while maintaining compatibility to Traveling Salesman, find an efficient data storage architecture and improve the search algorithm for nearest nodes. The next sections will outline the abstract framework designed to approach these problems.\newline

TODO: still to mention:
\begin{itemize}
	\item filtering intermediate way nodes implies need for an extra field holding distance between street nodes.
	\item derivates of Traveling Salesman's classes \texttt{Node}, \texttt{Way} and \texttt{WayNode}.
\end{itemize}

\subsubsection{Reducing and individualizing of routing data}

The basic idea is to introduce a module, an abstract Java class named \texttt{MobileDataSetProvider}, that can be queried for a specialized set of routing data which is compatible with Traveling Salesman and optimized for an individual routing operation. Any Traveling Salesman router may then be called with a reference to this individual data set. Anyhow, a router can perform another routing operation with different parameters on the same data set, but since the majority of intermediate way nodes will not be included in the data set, it will probably not find the best route or might even fail.\newline

One can also think of adding functionality to recycle an individualized data set. Instead of creating a new one for each routing operation, an old data set may be updated to be as qualified as if it was created specifically for the new parameters. One may be tempted to believe this is the only way to significantly gain time resources, but we will show that in fact our implementation exploits major improvements without this feature.\newline

\subsubsection{Data storage architecture}

The data set provider itself reads data from a suitable data source (for example from database or a file stream). Since even individualized data sets will have a large intersection, data is cached in memory to a great extent.\newline

As an abstraction of the data access to a routing data sources, a Java interface (called \texttt{RoutingDataAdapter}) is introduced. It provides methods to read map elements from a given data source.\newline


\subsubsection{Search algorithm for nearest nodes}

As already demonstrated, the search for the nearest street node is an integral part of a routing operation. Without any assumption about the chronological and geographical pattern of routing operations that will be performed, one has to improve the data structure storing the nodes to be qualified for fast random access. Anyhow, one can think of another way to speed up the search when analyzing the average use.\newline

Besides 


\subsubsection{Routing engine of MobileTSM}

\begin{itemize}
		
	\item Class \texttt{MobileTSMRoutingEngine}
	
		The class \texttt{MobileRoutingEngine} is the \emph{MobileTSM} implementation of a \texttt{RoutingEngine}.
		
	\item Class \texttt{Vehicle}
		
	\item Class \texttt{Limits}

\end{itemize}



