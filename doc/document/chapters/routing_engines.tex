In our project's scope, the routing engine is ought to be used and thus its output is required to give answer to the following two questions:

\begin{enumerate}

	\item How long does it (approximately) take to follow the shortest path between two locations?
	
		To give a good answer to this question, one has not only to specify two locations as starting point and destination of the route, but also a vehicle that will be used to travel this route, since its choice might influence\footnote{think of oneways which normally are free to be used in both directions when for example riding a bicycle} the route. In addition to this, remember we are mainly interested in the \emph{time} needed to travel the route, not its \emph{distance}. For this, in a first step we have to combine the maximum speed of the vehicle with the distance of the route. As a secound step, one should also consider local speed limitations, which effectively influence the vehicle's maximum speed on a certain part of the route.
	
	\item Where, looking from a specfic location, is (are) the next Point(s) Of Interest providing a specific type of service?
	
		Finding a statisfying answer to that question is in principle very easy. One has to scan the local area around the given center for facilities that match the criteria and give a list of the nearest ones.

\end{enumerate}

Having defined the information we are aiming for when triggering an operation of the routing engine, the following gives a brief overview of already existing open source routing engines that may be used in our project:

\begin{enumerate}

	\item \textbf{Gosmore}
	
		Gosmore is a routing and navigation software for mobile devices. It consequently also consists of a very efficient routing engine to operate on data coming originally from Openstreetmap, but which is reorganized and compressed in a very smart way in advance. For this, data is ordered in a way that tries to minimize the probablity of a cache-miss and the number of comparisons needed when searching the local map for special map elements.
		Gosmore is based on C/C++, very compact and makes extensive use of pointers and indirect memory access. Documentation of its source code is poor and thus it is not easy to comprehend and retrace its code.
	
	\item \textbf{OSMAndroid}
	
		OSMAndroid is a map viewer and routing engine for Android using precompiled Openstreetmap data. It uses a special OSMAndroidConverter to parse the bulky Openstreetmap XML file and to compress it to an extremely small 	proprietary data structure, maintaining only map elements needed for routing. Its very slight data model results in little and fast data access operations and very efficient routing operations.
		OSMAndroid's source code has rare comments and follows a sometimes confusing design pattern, but is because of its compactness understandable with not to much effort.
	
	\item \textbf{Traveling Salesman (TSM)}
	
		Traveling Salesman is a Java based open source navigation and routing framework using Openstreetmap data as its input\footnote{actually it is using Osmosis as an interface to Openstreetmap data, which is a java application for processing Openstreetmap data}. It has a consistent modular architecture and allows to assemble a specific navigation software nearly ''just-as-you-like''. Traveling Salesman comes with ready-to-use implementations for every module. These modules are by default designed to keep every map element and not to filter irrelevant\footnote{irrelevant in the sense that the result of any operation that may be performed does not depend on the element's presence or absence} ones. This results in a maximum generality at the cost of performance and memory space.
		Traveling Salesman is up to now still in beta stage.

\end{enumerate}

Since the target platform is a mobile one and resources will be limited, handling of available device resources is a crucial issue in the decision for a routing engine. Nevertheless it is not the only thing to think of in this context. In addition to the output requirements mentioned at the beginning of this chapter, there are other issues to account for. Some of them are for example the portability to our target platform and the flexibility for future adaptions and extensions.\newline

When trying to assign priorities to these aspects just mentioned before, one will be faced with the question whether to aim for a maximum of flexibility or for a maximum of performance, since these two features are contradictory in many ways. Traveling Salesman is situated near the end of the scale where focus is set on a maximum of flexibility, while Gosmore and OSMAndroid can be found near the other end. Balancing these priorities was dynamically done during technology scouting and therefore the next chapter will give considerations and results on this aspect in greater detail.\newline

Anyhow, as an integral part of the abstraction of the application's structure, the routing interface is designed in a way, that makes it independent of the decision for any routing engine, even if its design was influenced by it. This means, that although a final decision had to be made within the scope of our project, there is still the chance to choose another engine as part of future work.\newline

\subsubsection{Technology scouting - general part}

This section will give an overview of the general Technology Scouting process.\newline

Before focusing on a single routing engine, we analyzed the given options of routing engines with respect to our definitions. Unfortunately when doing the technology scouting, we did not know about the OSMAndroid routing engine and thus had no chance to consider it in the decision for a routing engine. Although its analysis has been done when a final decision already had been made and the technology scouting phase had been finished, the reasons for us not to change this decision afterwards will be given in this chapter.\newline

With the two options given at the beginning of the technology scouting phase, Gosmore and Traveling Salesman, the Traveling Salesman project had the considerable advantage of being based on Java, in contrast to Gosmore, which is effectively a C/C++ library. This fact gave rise to put first focus on Traveling Salesman to identify its drawbacks and opportunities.\newline

As our analysis revealed that Traveling Salesman is the most promising option\footnote{remember the only alternative at that time was Gosmore}, a discussion of this analysis will be given in a later chapter in greater detail. At this point, we will give a rough overview of the analysis of Gosmore, Traveling Salesman and OSMAndroid. In Addition to these three we will give a summary of considerations towards a proprietary development at the best combining advantages and opportunities of existing projects and excluding performance bottlenecks.\newline

\begin{itemize}

	\item \textbf{Gosmore}	
	
		TODO: explain why not Gosmore
	
	\item \textbf{Traveling Salesman (TSM)}
	
		First integration of Traveling Salesman's library into an Android project was rather simple, just as one would expect. It was integrated into a first application which was designed to use TSM to read an Openstreetmap XML file stored on the SD card of the mobile device and to output the file's summarized content. Compiling and running this application was possible without any errors but revealed three initial problems:
		
		\begin{itemize}
		
			\item Traveling Salesman uses a proprietary \texttt{FileLoader} class to read the Openstreetmap XML file and to initialize a  \texttt{MemoryDataSet} object holding all data from the XML file. This \texttt{FileLoader} in turn uses the java built-in  \texttt{SAXParser}\footnote{ \texttt{javax.xml.parsers.SAXParser}} class and an extension of the  \texttt{DefaultHandler}\footnote{\texttt{org.xml.sax.helpers.DefaultHandler}} class which seem to be implemented slightly different in Android's java library. A permutation in the parameters of the method  \texttt{startElement(...)} yielded a complete discapability of reading the XML file, but could be overcome by re-permutating its parameters.
			
			\item After having fixed the problem given in the previous clause, Traveling Salesman did its first job on both the emulator and a physical mobile device. With minor additions to our application, we were able to perfom a \texttt{getNearestNode(...)} query on a tiny data set, showing that we will get into big trouble concerning performance, if no adaptions were applied. However, we were able to show that improving Traveling Salesman's performance in a way satisfying our requirements is in principle possible and an issue one will be able to deal with (chapter \ref{sec:techscout_routing_specific} will give details).	

			\item memory usage	
		
		\end{itemize}

	\item \textbf{proprietary development}

		The possibility to use the given routing engines only as a source of inspiration and to start a proprietary development began to cross our minds, when ideas of how to design a routing engine became clear. Deliberation of combining a slight and efficient data storage system (like Gosmore is using), a reduced routing graph to operate on and java based source code (like Traveling Salesman has) occupied our minds. This thoughts were triggered by becoming aware of the fact that Traveling Salesman is in principle much more than we need and Gosmore in turn would need too much manipulations to be compatible with the Android system.

	\item \textbf{OSMAndroid}

		TODO: explain why not OSMAndroid	

\end{itemize}

Eventually we decided to base the routing engine on the Traveling Salesman project, maintaining compatibility to its modular architecture. This decision was forced by the following reasons

\begin{itemize}
	\item Java based source code
	
		Traveling Salesman is completely based on Java and does not use any external libraries. Its precompiled project library can easily be integrated in the Android environment and Android projects following the standard design approach and thus requiring zero investment in any abnormality with respect to this standard.
	
	\item adaptions and extensions may be implemented without touching its inner structure
	
		Traveling Salesman's modular architecture supports easy exchange of any of its components. Given the imperative need of an adapted data storage management system to improve utilization of resources, we could easily come up with a re-design of this component without the need of adapting other components. The same applies to modifications of both the routing algorithm and its routing metric which can each be modified independently of the other.
	
	\item maximum generality and flexibilty, exchangeable components
	
		Keeping compatibility to Traveling Salesman's modular architecture will offer the chance for easy maintenance or even upgrades. One may consequently benefit from future modifications made to the original Traveling Salesman project.
	
	\item performance improvements
	
		Early progress made with improving its performance gave rise to the assumption, that the advantages given in the clauses before will doubtlessly outweight the loss of performance and advantages provided by other solutions.
		
	\item "flexibility before performance"
	
		Last but not least, ...
	
\end{itemize}


The following chapter will give a more detailed introduction in the structure of Traveling Salesman.

\subsubsection{Traveling Salesman}

As already mentioned, Traveling Salesman is designed following a modular architecture. Every essential or optional type of module is defined by a java interface with basic methods to provide its desired functionality. The most important ones in our project are

\begin{itemize}

	\item Interface \texttt{IDataSet}
	
		\texttt{IDataSet} provides methods to store and receive Openstreetmap map elements. Identification of elements to receive can either be done by unique Openstreetmap ID or by parameters to search for. This, for example, may be the name of the element or simply its distance to a specific point, that has to fall below a cetain value.\newline
		 In dependence of its implementation, data storage is done in memory (\texttt{MemoryDataSet}), on disc or in a database.
	
	\item Interface \texttt{IRouter}

		\texttt{IRouter} is the interface which has to be implemented by any routing class. Its primary task is triggered by calling the \texttt{route(...)} method, which performs routing between a point to start from an one or more destination points. One has to pass an \texttt{IDataSet} object specifying routing resources, when calling \texttt{route(...)}. The router is to return a \texttt{Route} object containing detailed information about the path.
	
	\item Interface \texttt{IRoutingMetric}
	
		As to give the router a  measure of routing costs, one has to define a class implementing the \texttt{IRoutingMetric} interface, which allows the router to query routing costs of particular routing steps.\newline
		The default implementation (\texttt{ShortestRouteMetric}) simply measures distance between start and end of a routing step. One might feel uncomfortable with this, because it does not privilege any type of street and hence the shortest route is probably not the fastest one. However, this can be overcome with a re-implementation of a routing metric.
	
\end{itemize}

To represent Openstreetmap map elements (nodes, ways and relations), Traveling Salesman uses classes provided by Osmosis, which can be considered as a Java based framework for processing of Openstreetmap data. Osmosis employs classes named \texttt{Node}, \texttt{Way} and \texttt{Relation} to represent Openstreetmap map elements accordingly. 

\subsubsection{Technology scouting - specific part}
\label{sec:techscout_routing_specific}

This section will give an overview over the Traveling Salesman specific Technology Scouting process.\newline

- changes applied to the XML parser

- test system (mainly map file) used to make first progress with performance

[...]

